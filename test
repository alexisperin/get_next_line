The open() system call opens the file specified by pathname.  If the specified file does not exist, it may optionally (if O_CREAT is specified in flags) be created by open().

		The  return  value  of  open() is a file descriptor, a small, nonnegative integer that is used in subsequent system calls (read(2), write(2), lseek(2), fcntl(2), etc.) to refer to the open
		file.  The file descriptor returned by a successful call will be the lowest-numbered file descriptor not currently open for the process.

		By default, the new file descriptor is set to remain open across an execve(2) (i.e., the FD_CLOEXEC file descriptor flag described in fcntl(2) is initially disabled); the  O_CLOEXEC  flag,
		described below, can be used to change this default.  The file offset is set to the beginning of the file (see lseek(2)).

		A call to open() creates a new open file description, an entry in the system-wide table of open files.  The open file description records the file offset and the file status flags (see be‐
		low).  A file descriptor is a reference to an open file description; this reference is unaffected if pathname is subsequently removed or modified to refer to a different file.  For further
		details on open file descriptions, see NOTES.

		The argument flags must include one of the following access modes: O_RDONLY, O_WRONLY, or O_RDWR.  These request opening the file read-only, write-only, or read/write, respectively.

		In  addition,  zero or more file creation flags and file status flags can be bitwise-or'd in flags.  The file creation flags are O_CLOEXEC, O_CREAT, O_DIRECTORY, O_EXCL, O_NOCTTY, O_NOFOL‐
		LOW, O_TMPFILE, and O_TRUNC.  The file status flags are all of the remaining flags listed below.  The distinction between these two groups of flags is that the file creation  flags  affect
		the semantics of the open operation itself, while the file status flags affect the semantics of subsequent I/O operations.  The file status flags can be retrieved and (in some cases) modi‐
		fied; see fcntl(2) for details.

		The full list of file creation flags and file status flags is as follows:

		O_APPEND
				The file is opened in append mode.  Before each write(2), the file offset is positioned at the end of the file, as if with lseek(2).  The modification of the  file  offset  and  the
				write operation are performed as a single atomic step.

				O_APPEND  may  lead  to corrupted files on NFS filesystems if more than one process appends data to a file at once.  This is because NFS does not support appending to a file, so the
				client kernel has to simulate it, which can't be done without a race condition.

		O_ASYNC
				Enable signal-driven I/O: generate a signal (SIGIO by default, but this can be changed via fcntl(2)) when input or output becomes possible on this file descriptor.  This feature  is
				available only for terminals, pseudoterminals, sockets, and (since Linux 2.6) pipes and FIFOs.  See fcntl(2) for further details.  See also BUGS, below.

		O_CLOEXEC (since Linux 2.6.23)
				Enable the close-on-exec flag for the new file descriptor.  Specifying this flag permits a program to avoid additional fcntl(2) F_SETFD operations to set the FD_CLOEXEC flag.

				Note  that the use of this flag is essential in some multithreaded programs, because using a separate fcntl(2) F_SETFD operation to set the FD_CLOEXEC flag does not suffice to avoid
				race conditions where one thread opens a file descriptor and attempts to set its close-on-exec flag using fcntl(2) at the same time as another thread does a fork(2) plus  execve(2).
				Depending on the order of execution, the race may lead to the file descriptor returned by open() being unintentionally leaked to the program executed by the child process created by
				fork(2).  (This kind of race is in principle possible for any system call that creates a file descriptor whose close-on-exec flag should be set, and various other Linux system calls
				provide an equivalent of the O_CLOEXEC flag to deal with this problem.)